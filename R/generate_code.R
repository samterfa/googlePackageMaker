this_package <- 'googlePackageMaker'

# Formerly googleAuthR::gar_create_api_skeleton()
#' Create an API library skeleton
#' 
#' This will create a file with the skeleton of the API functions 
#'   for the specified library
#' 
#' @param output_dir Directory to write the package to
#' @param package_name Name of the package to create
#' @param api_json The json from \link{discovery_api}
#' 
#' @return TRUE if successful, side effect will write a file
#' @family Google Discovery API functions
#' @export
create_api_skeleton <- function(output_dir,
                                package_name,
                                api_json){
     
     final_package_path <- glue::glue('{output_dir}/{package_name}') %>% sub(pattern = '//', replacement = '/')
     
     if(dir.exists(final_package_path)){
             readline(glue::glue('{final_package_path} exists and will be overwritten! Press ESC to abort.'))
     }
     
     if(!dir.exists(output_dir)) dir.create(output_dir)
     if(!dir.exists(tempdir())) dir.create(tempdir())
     
     temp_package_dir <- glue::glue('{tempdir()}/{package_name}')
     if(!dir.exists(temp_package_dir)) dir.create(temp_package_dir)
     
     temp_script_dir <- glue::glue('{temp_package_dir}/R')
     if(!dir.exists(temp_script_dir)) dir.create(temp_script_dir)
     
     for(category in names(api_json$resources)) file.create(glue::glue('{temp_script_dir}/{category}.R'))
     
     # form strings which can be evaluated to subset json documentation for methods
     methods <- api_json$resources %>% unlist(recursive = T) %>% names() %>%purrr::keep(~(.x %>% stringr::str_detect('methods.*.id')) & (.x %>% stringr::str_detect('.id$'))) %>% stringr::str_replace_all('.id$', '')
     method_docs <- paste0('api_json$resources$', methods %>% stringr::str_replace_all(stringr::fixed('.'), '$')) %>% sort()
     base_url <- api_json$rootUrl   ### NOT baseUrl since Gargle doesn't handle multiple forward slashes in the base_url field of a request.
     path_prefix <- sub(api_json$rootUrl, '', api_json$baseUrl)
     
     # https://developers.google.com/discovery/v1/reference/apis
     for(method_doc in method_docs){
          
          # category of the function and file destination of the function code
          category <- method_doc %>% stringr::str_replace(stringr::fixed('api_json$resources$'), '') %>% stringr::str_sub(1,stringr::str_locate(., stringr::fixed('$'))[[1]] - 1)
          
          # documentation json subsetted by method
          method_info <- eval(parse(text = method_doc))
          
          # function name i function id. may revisit
          function_id <- method_info$id
          function_name <- function_id
          
          # description of function
          function_description <- method_info$description
          
          # path for api calls. Not sure whether to use flatPath or path yet.
          path <- paste0(path_prefix, method_info$path)
          
          # api method for call
          method <- method_info$httpMethod
          
          # vector of scopes needed to make the given api call
          scopes <- method_info$scopes
          
          # relevant schema for body of the request
          if(!is.null(method_info$request)){
               
               body_schema_ref <- method_info$request$`ref`
               
               body_schema <- api_json$schemas[body_schema_ref]
          }else{
               
               body_schema_ref <- NULL
               
               body_schema <- NULL
          }
          
          # relevant schema for response of the request
          if(!is.null(method_info$request)){
               
               response_schema_ref <- method_info$request$`ref`
               
               response_schema <- api_json$schemas[response_schema_ref]
          }else{
               
               response_schema_ref <- NULL
               
               response_schema <- NULL
          }
          
          # parameter names ordered - likely not important because gargle takes care of substitutions
          param_order <- method_info$parameterOrder
          
          # list of path and query parameters for api call ordered by param_order
          params <- method_info$parameters
          if(length(param_order) > 0) params <- params[param_order]
          
          
          ############ Generate documentation text ###############
          
          doctext <- glue::glue(
               
               "\n\t",
               "#' {function_description}",
               "\n\t",
               "#'",
               "\n\t",
               "#' Autogenerated via \\code{{\\link[{this_package}]{{create_api_skeleton}}}}",
               "\n\t",
               "#'",
               "\n\t",
               "#' @seealso \\href{{{api_json$documentationLink}}}{{Google Documentation}}",
               "\n\t",
               "#'",
               "\n\t",
               "#' @details",
               "\n\t",
               "#' Authentication scopes used by this function are:",
               "\n\t",
               "#' \\itemize{{", 
               
               .trim = F)
          
          for(scope in scopes){
               
               doctext <- glue::glue("{doctext}",
                                     "\n\t",
                                     "#' \\item {scope}", 
                                     .trim = F)
          }
          
          doctext <- glue::glue("{doctext}", 
                                "\n\t",
                                "#' }}", 
                                .trim = F)
          
          for(param in names(params)){
               
               param_info <- method_info$parameters[[param]]
               
               doctext <- glue::glue("{doctext}",
                                     "\n\t",
                                     "#' @param {param} {param_info$description}", 
                                     .trim = F)
          }
          
          doctext <- glue::glue("{doctext}", 
                                "\n\t",
                                "#' @param token A token prepared by one of Gargle's token generating functions. Defaults to NULL (call \\code{{\\link[gargle]{{token_fetch}}}} with appropriate scopes).",
                                "\n\t",
                                "#' @param return_response Whether to return the response or the response content. Defaults to FALSE (return response content).", 
                                .trim = F)
          
          doctext <- glue::glue("{doctext}",
                                "\n\t",
                                "#' @export", 
                                .trim = F)
          
          ############ Generate function text ###############
          
          functiontext <- glue::glue("\t",
                                     "{function_name} <- function(", 
                                     .trim = F)
          
          for(param in names(params)){
               
               param_info <- method_info$parameters[[param]]
               
               functiontext <- glue::glue("{functiontext}","{param} = NULL, ", .trim = F)
               
          }
          
          # Finish off function parameters list
          functiontext <- paste0(functiontext, 'token = NULL, return_response = F){')
          
          scopes_text <- paste0("c('", paste(scopes, collapse = "', '"), "')") 
          
          # Build function
          # TODO: NEED TO ADD useragent to request_make.
          functiontext <- glue::glue("{functiontext}", 
                                     "\n\t\t",
                                     "params <- as.list(environment())[!names(as.list(environment())) %in% c('body', 'return_response', 'token')]",
                                     "\n\t\t",
                                     "scopes <- {scopes_text} %>% strsplit(',') %>% purrr::pluck(1)",
                                     "\n\t\t",
                                     "if(is.null(token)) token <- gargle::token_fetch(scopes = scopes)",
                                     "\n\t\t",
                                     "req <- gargle::request_build(method = '{method}', path = '{path}', params = params, body = NULL, token = token, base_url = '{base_url}')",
                                     "\n\t\t",
                                     "res <- gargle::request_make(req, encode = 'json')",
                                     "\n\t\t",
                                     "res",
                                     "\n\t",
                                     "}",
                                     .trim = F)
          
          # Update appropriate file with new documentation and function.
          readr::write_lines(doctext, glue::glue('{temp_script_dir}/{category}.R'), append = T)
          readr::write_lines(functiontext, glue::glue('{temp_script_dir}/{category}.R'), append = T)
          
     }
     
     # Output package files
     file.copy(from = temp_package_dir, to = output_dir, recursive = T, overwrite = T)
     
     T
}

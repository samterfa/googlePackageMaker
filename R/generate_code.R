this_package <- 'googlePackageMaker'

# Formerly googleAuthR::gar_create_api_skeleton()
#' Create a Google API package
#' 
#' This function will generate a package of Google API functions.
#' 
#' @api_id The api to fetch. Run \code{\link[{this_package}]{list_google_apis} for options.
#' @param output_dir Directory path to write the package to.
#' @param package_name Name of the package to create.
#' 
#' @return TRUE if successful, side effect will write package directory {output_dir}/{package_name}.
#' @family Google Discovery API functions
#' @export
make_google_package <- function(api_id,
                                output_dir,
                                package_name){
   
   ############ Create package file structure ############
   final_package_path <- glue::glue('{output_dir}/{package_name}') %>% sub(pattern = '//', replacement = '/')
   
   if(dir.exists(final_package_path)){
      readline(glue::glue('{final_package_path} exists and will be overwritten! Press ESC to abort.'))
   }
   
   if(!dir.exists(output_dir)) dir.create(output_dir)
   if(!dir.exists(tempdir())) dir.create(tempdir())
   
   temp_package_dir <- glue::glue('{tempdir()}/{package_name}')
   if(dir.exists(temp_package_dir)) unlink(temp_package_dir, recursive = T, force = T)
   
   dir.create(temp_package_dir)
   
   temp_script_dir <- glue::glue('{temp_package_dir}/R')
   dir.create(temp_script_dir)
   
   temp_data_raw_dir <- glue::glue('{temp_package_dir}/data-raw')
   dir.create(temp_data_raw_dir)
   
   
   ### ADD usethis function calls for package generation here.
   
   
   
   # Load API info
   suppressMessages(
      discovery_docs <- preprocess_methods(api_id, temp_data_raw_dir)
   )
   api_info <- discovery_docs[[1]]
   methods <- discovery_docs[[2]]
   ###   api_info <- get_google_api(api_name, api_version)
   
   # Form strings which can be evaluated to subset json documentation for methods
   base_url <- api_info$rootUrl   ### NOT baseUrl since gargle doesn't handle multiple forward slashes in the base_url field of a request.
   path_prefix <- sub(api_info$rootUrl, '', api_info$baseUrl)
   
   # https://developers.google.com/discovery/v1/reference/apis
   for(method_info in methods){
      
      # method ids are of the form {api}.{category}.{...}. Need to peel off category.
      start <- stringr::str_locate_all(method_info$id, stringr::fixed('.'))[[1]][[1]] + 1
      end <- stringr::str_locate_all(method_info$id, stringr::fixed('.'))[[1]][[2]] - 1
      
      category <- method_info$id %>% stringr::str_sub(start, end = end)
      category_file <- glue::glue('{temp_script_dir}/{category}.R')
      
      if(!file.exists(category_file)) file.create(category_file)
      
      # function name is function id. may revisit
      function_id <- method_info$id
      function_name <- function_id
      
      # description of function
      function_description <- method_info$description
      
      # path for api calls. Not sure whether to use flatPath or path yet.
      path <- paste0(path_prefix, method_info$path)
      
      # api method for call
      method <- method_info$httpMethod
      
      # vector of scopes needed to make the given api call
      scopes <- method_info$scopes
      
      # relevant schema for response of the request
      if(!is.null(method_info$request)){
         response_schema_ref <- method_info$request
      }else{
         response_schema_ref <- NULL
      }
      
      params <- method_info$parameters
      read_only_param_names <- params %>% purrr::keep(~'readOnly' %in% names(.x)) %>% purrr::keep(~.x$readOnly) %>% names()
      params <- params[!names(params) %in% read_only_param_names]
      required_param_names <- params %>% purrr::keep(~'required' %in% names(.x)) %>% purrr::keep(~.x$required) %>% names()
      params <- params[!names(params) %in% c('access_token', 'oauth_token', 'key')]
      
      # Order params by whether they're required or not.
      params <- append(
         params[names(params) %in% required_param_names],
         params[!names(params) %in% required_param_names]
      )
      
      if(length(function_description) == 0){
         return(function_name)
      }
      
      ############ Generate documentation text ############
      doc_text <- glue::glue(
         
         "\n\t",
         "#' {function_description}",
         "\n\t",
         "#'",
         "\n\t",
         "#' Autogenerated via \\code{{\\link[{this_package}]{{generate_google_package}}}}",
         "\n\t",
         "#'",
         "\n\t",
         "#' @seealso \\href{{{api_info$documentationLink}}}{{Google Documentation}}",
         "\n\t",
         "#'",
         "\n\t",
         "#' @details",
         "\n\t",
         "#' Authentication scopes used by this function are:",
         "\n\t",
         "#' \\itemize{{", 
         
         .trim = F)
      
      for(scope in scopes){
         
         doc_text <- glue::glue("{doc_text}",
                                "\n\t",
                                "#' \\item {scope}", 
                                .trim = F)
      }
      
      doc_text <- glue::glue("{doc_text}", 
                             "\n\t",
                             "#' }}", 
                             .trim = F)
      
      # Add function params to documentation.
      for(param in names(params)){
         
         param_info <- method_info$parameters[[param]]
         
         doc_text <- glue::glue("{doc_text}",
                                "\n\t",
                                "#' @param {param} {param_info$description %>% stringr::str_replace_all(stringr::fixed('\n'), '')}", 
                                .trim = F)
      }
      
      # Add token and return_response as well.
      doc_text <- glue::glue("{doc_text}", 
                             "\n\t",
                             "#' @param gargle_token A token prepared by one of gargle's token generating functions. Defaults to gargle::token_fetch(...) with the scopes listed above. See \\code{{\\link[gargle]{{token_fetch}}}} for more info.",
                             "\n\t",
                             "#' @param return_response Whether to return the response or the response content. Defaults to FALSE (return response content).", 
                             .trim = F)
      
      doc_text <- glue::glue("{doc_text}",
                             "\n\t",
                             "#' @export", 
                             .trim = F)
      
      ############ Generate function text ###############
      function_text <- glue::glue("\t",
                                  "{function_name} <- function(",
                                  .trim = F)
      
      # Add params to function definition.
      for(param in names(params)){
         
         if(param %in% required_param_names){
            function_text <- glue::glue("{function_text}", "{param}, ")
         }else{
            function_text <- glue::glue("{function_text}", "{param} = NULL, ")
         }
      }
      
      # Finish off function parameters list
      function_text <- glue::glue("{function_text}",
                                  ####         "token = gargle::token_fetch(scopes = get_function_scopes('{function_name}')), return_response = F, fields = NULL){{",
                                  "gargle_token = gargle::token_fetch(scopes = .endpoints[['{function_id}']]$scopes), return_response = F){{",
                                  .trim = F)
      
      # Build function
      # TODO: NEED TO ADD useragent to request_make.
      function_text <- glue::glue("{function_text}", 
                                  "\n\t\t",
                                  "params <- as.list(environment())[!names(as.list(environment())) %in% c(",
                                  ###         ifelse(!is.null(body_schema_ref), "'{body_schema_ref}', ", ""),
                                  "'return_response', 'gargle_token')]",
                                  "\n\t\t",
                                    "req <- request_develop(endpoint = .endpoints[['{function_id}']], params = params)",
                                  "\n\t\t",
                                  "req <- request_build(method = req$method, path = req$path, params = req$params, body = req$body, token = httr::config(token = gargle_token))",
                                  "\n\t\t",
                                  "res <- request_make(req, encode = 'json')",
                                  
                              ####    "req <- gargle::request_build(method = '{method}', path = '{path}', params = params, ",
                                  ###        ifelse(!is.null(body_schema_ref), "body = {body_schema_ref}, ", ""),
                               ####   "token = httr::config(token = gargle_token), base_url = '{base_url}')",
                              ####    "\n\t\t",
                            ####      "res <- gargle::request_make(req, encode = 'json')",
                                  "\n\t\t",
                                  "if(return_response) return(res)",
                                  "\n\t\t",
                                  "httr::content(res)",
                                  "\n\t",
                                  "}",
                                  .trim = F)
      
      # Update appropriate file with new documentation and function.
      readr::write_lines(doc_text, category_file, append = T)
      readr::write_lines(function_text, category_file, append = T)
   }
   
   # Output package files
   for(file_to_remove in list.files(glue::glue('{final_package_path}/R'))){
      file.remove(glue::glue('{final_package_path}/R/{file_to_remove}'))
   }
   file.copy(from = temp_package_dir, to = output_dir, recursive = T, overwrite = T)
   
   T
}
